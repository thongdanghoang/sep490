package sep490.idp.entity;


import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.Hibernate;
import org.hibernate.Session;
import org.hibernate.proxy.HibernateProxy;
import org.hibernate.proxy.LazyInitializer;
import sep490.common.api.exceptions.TechnicalException;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;

public class JpaUtils {

    @PersistenceContext
    private EntityManager em;

    public EntityManager getEntityManager() {
        return em;
    }

    public static boolean isInitialized(Object object) {
        return Hibernate.isInitialized(object);
    }

    /**
     * Get the class of an instance or the underlying class
     * of a proxy (without initializing the proxy!). It is
     * almost always better to use the entity name!
     */
    public static Class<?> getPersistenceClassWithoutInitializingProxy(Object entity) {
        if (entity instanceof HibernateProxy proxy) {
            LazyInitializer li = proxy.getHibernateLazyInitializer();
            return li.getPersistentClass();
        } else {
            return entity.getClass();
        }
    }

    /**
     * Remove the given entity from the persistence context
     */
    public void detach(Object object) {
        em.detach(object);
    }

    /**
     * Turns on Hibernate filter whose name is specified by <code>filterName</code> with the input
     * <code>params</code>.
     *
     * @param filterName Name of the filter to be enabled.
     * @param params     Parameters to be used for the filter.
     */
    public void enableFilter(String filterName, Map<String, Object> params, Map<String, Collection<?>> collectionParams) {
        var filter = getEntityManager().unwrap(Session.class).enableFilter(filterName);
        params.forEach(filter::setParameter);
        collectionParams.forEach(filter::setParameterList);
    }

    public void disableFilter(String filterName) {
        getEntityManager().unwrap(Session.class).disableFilter(filterName);
    }

    /**
     * Initializes a Hibernate entity by touching its graph. Queries generated by this touch will
     * therefore fully respect what have been configured at entity mapping level.
     *
     * @param result       The entity itself.
     * @param associations List of associations to be initialized.
     * @return The entity (for convenient coding).
     */
    public static <T> T initialize(T result, String... associations) {
        if (result == null) {
            return null;
        }
        for (String association : associations) {
            initializeInternal(result, association);
        }
        return result;
    }

    public static <T> List<T> initializeList(List<T> result, String... associations) {
        if (result == null) {
            return Collections.emptyList();
        }
        result.forEach(r -> initialize(r, associations));
        return result;
    }

    private static void initializeInternal(Object result, String association) {
        try {
            BeanInfo bi = Introspector.getBeanInfo(result.getClass());
            var propertyDescriptors = Arrays
                    .stream(bi.getPropertyDescriptors())
                    .filter(propertyDescriptor -> StringUtils.equals(association, propertyDescriptor.getName()))
                    .toList();
            for (PropertyDescriptor md : propertyDescriptors) {
                Optional.ofNullable(md.getReadMethod().invoke(result)).ifPresent(Hibernate::initialize);
            }
        } catch (IntrospectionException | IllegalAccessException | IllegalArgumentException |
                 InvocationTargetException e) {
            throw new TechnicalException("Error occurred while initializing.", e);
        }
    }
}
